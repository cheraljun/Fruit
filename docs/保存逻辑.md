# 保存逻辑设计

## 核心原则：傻瓜式、零陷阱

保存逻辑遵循**严格的顺序执行**，避免所有异步陷阱、闭包陷阱和竞态条件。

## 自动保存机制

**触发方式：防抖式自动保存**
- 监听 `editor.nodes`、`editor.edges`、`editor.storyMeta`、`editor.variables` 的变化
- 用户停止编辑 0.1 秒后自动触发保存
- 使用 `setTimeout` + `clearTimeout` 实现防抖
- 连续编辑时定时器不断重置，只在停止编辑后保存

## 执行流程（不可打乱）

```
用户编辑状态（nodes/edges/meta/variables）
    ↓
状态变化触发 useEffect
    ↓
清除旧定时器，设置新的 0.1 秒定时器
    ↓
用户停止编辑 0.1 秒
    ↓
1. 防抖检查（autoSavingRef 锁）
    ↓
2. 先收集编辑面板数据
    ↓
3. 再更新内存状态
    ↓
4. 保存到后端（第1次）
    ↓
5. 基于信号等待第1次完成
    ↓
6. 保存到后端（第2次）
    ↓
7. 解锁，完成
```

## 三层数据收集

**第一层：NodeContentPanel（左侧）**
- 收集：文本、选项、节点类型、标签、打字机速度、节点脚本
- 返回：部分节点数据对象

**第二层：NodeVisualPanel（右侧）**
- 收集：背景图、角色立绘、热区数据、对话框UI配置
- 返回：部分节点数据对象

**第三层：BottomEditPanel（合并层）**
- 调用左右两个面板的 `applyChanges()`
- 合并所有数据和 `pluginData`
- 返回：完整节点数据对象

## 保存时序（Editor.tsx）

### 防抖自动保存 useEffect
```typescript
// 防抖式自动保存
useEffect(() => {
  // 初始加载时不触发
  if (loading || !hasUnsavedChanges) return;
  
  console.log('[自动保存] 检测到变化，0.1秒后保存');
  
  // 设置0.1秒防抖定时器
  const timer = setTimeout(async () => {
    if (!handleSaveRef.current) return;
    
    console.log('[自动保存] 开始保存...');
    autoSavingRef.current = true; // 加锁
    
    try {
      // 第一次保存
      const result1 = await handleSaveRef.current(false, true);
      console.log('[自动保存] 第1次:', result1);
      
      // 第二次保存（基于信号等待）
      const result2 = await handleSaveRef.current(false, true);
      console.log('[自动保存] 第2次:', result2);
      
      if (result1 && result2) {
        console.log('[自动保存] 保存完成 ✓');
      }
    } catch (error) {
      console.error('[自动保存] 保存失败:', error);
    } finally {
      autoSavingRef.current = false; // 解锁
    }
  }, 100);
  
  // 清理函数：状态再次变化时清除旧定时器
  return () => {
    clearTimeout(timer);
  };
}, [editor.nodes, editor.edges, editor.storyMeta, editor.variables, loading, hasUnsavedChanges]);
```

### handleSave 函数
```typescript
const handleSave = async (showNotification = true, isAutoSave = false) => {
  // 步骤1：检查状态锁
  if (!id || loading) return false;
  
  // 自动保存跳过 saving 检查，因为已用 autoSavingRef 做锁
  if (!isAutoSave && saving) return false;
  
  setSaving(true);
  
  // 步骤2：如果编辑面板打开，先收集数据
  if (editor.selectedNode && nodeEditPanelRef.current) {
    const editingNodeData = nodeEditPanelRef.current.applyChanges();
    if (editingNodeData) {
      // 步骤3：立即同步更新内存（React状态）
      editor.updateNodeData(editor.selectedNode.id, editingNodeData);
    }
  }
  
  // 步骤4：从内存读取最新状态（不依赖闭包）
  const currentNodes = editor.nodes.map(node => ({...}));
  const currentEdges = editor.edges.map(edge => ({...}));
  
  // 步骤5：构建保存对象
  const story = {
    id,
    meta: editor.storyMeta,
    nodes: currentNodes,
    edges: currentEdges,
    variables: editor.variables,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  // 步骤6：保存到后端
  await api.drafts.save(story);
  
  setSaving(false);
  return true;
};
```

## 关键设计决策

**手动保存 vs 自动保存**
- 选择：**防抖式自动保存**
- 原因：减少用户操作、自动持久化、用户停止编辑才触发（不频繁）

**为什么保存两次？**
- React 异步状态更新问题：第一次保存触发状态更新，第二次才能读到更新后的数据
- 使用 `await` 基于信号等待，不猜测延迟
- 这是已知的 workaround

**防抖 vs 轮询**
- 选择：防抖（`setTimeout` + `clearTimeout`）
- 原因：只在用户停止操作后触发，不浪费资源
- 连续编辑时定时器不断重置

**使用 useRef 避免依赖问题**
- `handleSaveRef` 保存 `handleSave` 的最新引用
- 防抖 `useEffect` 不包含 `handleSave` 依赖
- 避免其他无关状态变化导致定时器重置

**同步收集 vs 异步收集**
- 选择：同步收集（`applyChanges` 返回值）
- 原因：避免 Promise 竞态、保证数据完整性

**立即更新内存 vs 延迟更新**
- 选择：立即更新（步骤3）
- 原因：保证步骤4读到最新数据，避免闭包旧值

**单一数据源**
- `editor.nodes` 和 `editor.edges` 是唯一真相来源
- 所有面板的修改都通过 `updateNodeData` 写入
- 保存时从这里读取，不依赖局部状态

**锁机制**
- `autoSavingRef` 作为锁标志
- 自动保存时加锁，完成后解锁
- 自动保存跳过 `saving` 检查，因为已用 `autoSavingRef` 做锁

## 避免的陷阱

**❌ 闭包陷阱**
```typescript
// 错误：handleSave闭包捕获旧的nodes
const handleSave = () => {
  api.save({ nodes }); // 可能是旧数据
};
```

**✅ 正确做法**
```typescript
// 正确：从editor.nodes实时读取
const handleSave = () => {
  const currentNodes = editor.nodes; // 最新数据
  api.save({ nodes: currentNodes });
};
```

**❌ 异步竞态**
```typescript
// 错误：多个await可能导致数据不一致
const data1 = await panel1.getData();
const data2 = await panel2.getData(); // 此时data1可能已过期
```

**✅ 正确做法**
```typescript
// 正确：同步收集，一次性合并
const data1 = panel1.applyChanges();
const data2 = panel2.applyChanges();
const merged = { ...data1, ...data2 };
```

**❌ 状态竞态（保存两次时）**
```typescript
// 错误：saving 状态未更新，导致第二次保存被拦截
const result1 = await handleSave();
const result2 = await handleSave(); // 此时 saving 可能还是 true，返回 false
```

**✅ 正确做法**
```typescript
// 正确：自动保存跳过 saving 检查
if (!isAutoSave && saving) return false; // 只有非自动保存才检查 saving
```

**❌ 依赖陷阱（防抖定时器）**
```typescript
// 错误：useEffect 依赖包含 handleSave，导致其他状态变化重置定时器
useEffect(() => {
  const timer = setTimeout(() => {
    handleSave(); // 依赖函数
  }, 100);
  return () => clearTimeout(timer);
}, [nodes, edges, handleSave]); // handleSave 变化会重置定时器
```

**✅ 正确做法**
```typescript
// 正确：用 ref 保存函数引用
const handleSaveRef = useRef();
useEffect(() => {
  handleSaveRef.current = handleSave;
}, [handleSave]);

useEffect(() => {
  const timer = setTimeout(() => {
    handleSaveRef.current?.(); // 调用 ref
  }, 100);
  return () => clearTimeout(timer);
}, [nodes, edges]); // 只依赖要监听的状态
```

## 数据流向

```
用户输入
  ↓
本地状态（useState）
  ↓
applyChanges() 返回
  ↓
editor.updateNodeData()
  ↓
editor.nodes（单一数据源）触发 useEffect
    ↓
清除旧定时器，设置新的 0.1 秒定时器
    ↓
用户停止编辑 0.1 秒
    ↓
自动触发 handleSave()（两次）
  ↓
后端持久化
```

单向流动，每一步都是确定的、可预测的。

## 控制台日志

```
[自动保存] 检测到变化，0.1秒后保存
[自动保存] 开始保存...
[自动保存] 第1次: true
[自动保存] 第2次: true
[自动保存] 保存完成 ✓
```


